{"version":3,"file":"shiny.mjs","sources":["../src/index.js"],"sourcesContent":["const isBrowser = () => typeof window !== 'undefined' && typeof window.document !== 'undefined';\nconst isNumber = v => typeof v === 'number';\nconst isString = v => typeof v === 'string';\nconst isSupported = () => isBrowser() && 'DeviceOrientationEvent' in window;\n\nlet createShiny = () => {};\n\nif (isSupported()) {\n    \n    const STRENGTH = 300;\n    const PI_DIVIDED_BY_180 = Math.PI / 180;\n\n    // patterns\n    const generateNoise = (width, height) => {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = canvas.getContext('2d');\n        for (let x=0; x<width; x++) {\n            for (let y=0; y<height; y++) {\n                ctx.fillStyle = `rgba(0, 0, 0, ${ Math.random() })`;\n                ctx.fillRect(x, y, 1, 1);\n            }\n        }\n        return canvas;\n    }\n\n    const getPatternWithOpacity = (pattern, opacity) => {\n        const source = state.patterns[pattern];\n        if (!source) return null;\n        const canvas = document.createElement('canvas');\n        canvas.width = source.width;\n        canvas.height = source.height;\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = `rgba(0, 0, 0, ${ 1 - opacity })`;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        ctx.drawImage(source, 0, 0);\n        return canvas;\n    }\n\n    const state = {\n        orientationInitial: null,\n        orientation: {\n            alpha: null,\n            beta: null,\n            gamma: null\n        },\n        viewport: {\n            width: window.innerWidth,\n            height: window.innerHeight\n        },\n        origin: { x: 0, y: 0, z: STRENGTH },\n        patterns: {\n            noise: generateNoise(\n                64 * window.devicePixelRatio, \n                64 * window.devicePixelRatio\n            )\n        },\n        drawers: []\n    };\n\n\n    // add shiny layer\n    createShiny = (target, props) => \n        // find target if is query selector, always turns target result into an array\n        (typeof target === 'string' ? Array.from(document.querySelectorAll(target)) : Array.isArray(target) ? target : [target])\n        \n        // create drawer for target\n        .map(element => state.drawers.push(create(element, props)));\n\n\n    const getStateFromProps = (element, props) => {\n\n        const { gradient = {}, pattern = {} } = props;\n\n        const steps = sanitizeGradient(gradient.colors || ['#fff', 'rgba(255,255,255,0)']);\n\n        const flip = {\n            x: gradient.flip && gradient.flip.x ? -1 : 1,\n            y: gradient.flip && gradient.flip.y ? -1 : 1\n        }\n\n        const patternOpacity = isNumber(pattern.opacity) ? pattern.opacity : .25;\n\n        return {\n\n            type: props.type || 'background',\n            dirty: true,\n            styles: null,\n            element,\n\n            gradient: {\n                type: gradient.type || 'radial',\n                flip,\n                angle: gradient.angle || null,\n                steps,\n                scalar: gradient.scalar || { x:1, y:1 }\n            },\n\n            pattern: {\n                type: pattern.type || 'none',\n                data: pattern.type ? getPatternWithOpacity(pattern.type, patternOpacity).toDataURL() : null,\n                opacity: patternOpacity,\n                size: { width: 64, height: 64 }\n            }\n\n        };\n    }\n\n\n\n\n    const setup = (state) => {\n\n        const { type, element, styles, pattern, gradient } = state;\n        \n        // set positioning so overlay is positioned relative to parent\n        element.style.position = styles.position === 'static' ? 'relative' : styles.position;\n        \n        // create wrapper that will hold effects\n        const wrapper = document.createElement('span');\n        wrapper.className = 'shiny--wrapper';\n\n        // create effect overlay\n        let overlayStyles = 'position:absolute; pointer-events:none; user-select:none; background-attachment: fixed;';\n        const overlay = document.createElement('span');\n        const style = overlay.style;\n\n        if (type === 'border') {\n            const borderTopWidth = parseFloat(styles.borderTopWidth);\n            const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n            const borderRightWidth = parseFloat(styles.borderRightWidth);\n            const borderBottomWidth = parseFloat(styles.borderBottomWidth);\n            const borderTopLeftRadius = parseFloat(styles.borderTopLeftRadius);\n            const backgroundColor = styles.backgroundColor;\n            overlayStyles += `\n            border-radius: ${ borderTopLeftRadius }px; \n            left: ${ -borderLeftWidth }px;\n            top: ${ -borderTopWidth }px;\n            right: ${ -borderRightWidth }px;\n            bottom: ${ -borderBottomWidth }px;`\n\n            const fill = document.createElement('div');\n            fill.style.cssText = `position:absolute; \n            border-radius: ${ borderTopLeftRadius - borderLeftWidth }px; \n            left: ${ borderLeftWidth }px;\n            top: ${ borderTopWidth }px;\n            right: ${ borderRightWidth }px;\n            bottom: ${ borderBottomWidth }px;\n            background-color: ${ backgroundColor }`;\n            overlay.appendChild(fill);\n        }\n        else if (type === 'background') {\n            const borderTopLeftRadius = parseFloat(styles.borderTopLeftRadius);\n            overlayStyles += `left:0;top:0;width:100%;height:100%;border-radius:${ borderTopLeftRadius }px;`;\n        }\n        else if (type === 'text') {\n            overlay.innerHTML = element.innerHTML;\n            overlayStyles += `color:transparent; background-clip: text; -webkit-background-clip: text; -moz-background-clip: text;`;\n        }\n        \n        // add a pattern mask if needed\n        if (pattern.data) {\n            const mask = `url(${ pattern.data }) 0 0 / ${ pattern.size.width }px ${ pattern.size.height }px;`;\n            overlayStyles += `mask: ${ mask }; -moz-mask: ${ mask }; -webkit-mask: ${ mask };`;\n        }\n\n\n        // apply styles to overlay\n        style.cssText = overlayStyles;\n\n\n        // append overlay to DOM\n        wrapper.appendChild(overlay);\n        element.insertAdjacentElement('afterbegin', wrapper);\n        \n\n        // draw gradient based on \n        if (gradient.type === 'linear') {\n\n            return (x, y) => {\n                const offset = (x * gradient.flip.x) + (y * gradient.flip.y) / 2; \n                const gradientString = gradient.steps\n                    .map(value => `${ value.colorRGBA } ${ (offset + value.stop) * 100 }%`)\n                    .join(', ');\n                \n                style.backgroundImage = `linear-gradient(${ gradient.angle }, ${ gradientString })`;\n            }\n\n        }\n        else {\n\n            const gradientString = gradient.steps\n                .map(value => `${ value.colorRGBA } ${ value.stop * 100 }%`)\n                .join(', ');\n            \n            return (x, y) => {\n                const position = {\n                    x: .5 + (x * gradient.flip.x * gradient.scalar.x),\n                    y: .5 + (y * gradient.flip.y * gradient.scalar.y)\n                };\n                style.backgroundImage = `radial-gradient(100vmax 100vmax at ${ position.x * 100 }% ${ position.y * 100 }%, ${ gradientString })`;\n            }\n\n        }\n    }\n\n\n\n\n\n    // init and create drawer\n    const create = (element, props = {}) => {\n        \n        const state = getStateFromProps(element, props);\n\n        const init = () => {\n            state.styles = getComputedStyle(element);\n            const update = setup(state);\n            drawer.write = (x, y) => {\n                update(x, y);\n            }\n        }\n\n        const drawer = {\n            read: () => {\n                if (!state.dirty) return;\n                init();\n                state.dirty = false;\n            },\n            write: () => {}\n        };\n\n        return drawer;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    const sanitizeGradient = gradient => gradient\n        // make sure is array\n        .map(step => isString(step) ? [step] : step)\n        // reformat to object\n        .map(step => ({\n            color: isString(step[0]) ? step[0] : step[1],\n            opacity: isNumber(step[step.length - 1]) ? step[step.length - 1] : null,\n            stop: isNumber(step[0]) ? step[0] : null\n        }))\n        // set default values\n        .map((step, index, arr) => ({\n            ...step,\n            opacity: step.opacity === null ? 1 : step.opacity,\n            stop: step.stop === null ? index * (1 / (arr.length - 1)) : step.stop\n        }))\n        // add rgba\n        .map(step => ({\n            ...step,\n            colorRGBA: toRGBA(step.color, step.opacity)\n        }));\n\n    const toRGBA = (color, opacity) => `rgba${ toRGB(color).slice(3, -1) }, ${ opacity })`;\n\n    const toRGB = (color) => {\n        if (/rgb\\(/.test(color)) return color;\n        const node = document.createElement('div');\n        node.style.cssText = `display:none;color:${color}`;\n        document.body.appendChild(node);\n        const out = getComputedStyle(node).color;\n        node.parentNode.removeChild(node);\n        return out;\n    }\n\n\n\n\n\n\n    // convert degrees to radians\n    const degToRad = degrees => degrees * PI_DIVIDED_BY_180;\n\n    // draw orientation to screen\n    const draw = () => {\n\n        if (!state.orientationInitial) return;\n\n        const { orientation, orientationInitial, origin, viewport } = state;\n        \n        const alpha = orientationInitial.alpha - orientation.alpha;\n        const beta = orientationInitial.beta - orientation.beta;\n        const gamma = orientationInitial.gamma - orientation.gamma;\n        \n        let { x, y, z } = origin;\n\n        x = x * Math.cos(-degToRad(alpha)) - y * Math.sin(-degToRad(alpha));\n        y = y * Math.cos(-degToRad(alpha)) + x * Math.sin(-degToRad(alpha));\n        y = y * Math.cos(-degToRad(beta))  - z * Math.sin(-degToRad(beta));\n        z = z * Math.cos(-degToRad(beta))  + y * Math.sin(-degToRad(beta));\n        z = z * Math.cos(-degToRad(gamma)) - x * Math.sin(-degToRad(gamma));\n        x = x * Math.cos(-degToRad(gamma)) + z * Math.sin(-degToRad(gamma));\n\n        const viewportScaleFactor = viewport.width / viewport.height;\n        const px = x / (STRENGTH * viewportScaleFactor);\n        const py = y / (STRENGTH / viewportScaleFactor);\n        \n        // reads\n        state.drawers.forEach(drawer => drawer.read());\n\n        // writes\n        state.drawers.forEach(drawer => drawer.write(px, py));\n    }\n\n    // start draw loop\n    const tick = () => {\n        draw();\n        requestAnimationFrame(tick);\n    }\n\n    const init = () => {\n\n        // reset initial orientation when document is hidden/shown\n        document.addEventListener('visibilitychange', e => {\n            state.orientationInitial = null;\n        });\n\n        // register orientation changes\n        window.addEventListener('deviceorientation', e => {\n            if (e.alpha === null) return;\n            state.orientation.alpha = e.alpha;\n            state.orientation.beta = e.beta;\n            state.orientation.gamma = e.gamma;\n            if (state.orientationInitial === null) {\n                state.orientationInitial = {\n                    alpha: e.alpha,\n                    beta: e.beta,\n                    gamma: e.gamma\n                }\n                tick();\n            }\n        });\n\n    };\n\n    // run!\n    init();\n}\n\nexport default createShiny;"],"names":["const","isNumber","v","isString","createShiny","window","document","PI_DIVIDED_BY_180","Math","PI","getPatternWithOpacity","pattern","opacity","source","state","patterns","canvas","createElement","width","height","ctx","getContext","fillStyle","fillRect","drawImage","orientationInitial","orientation","alpha","beta","gamma","viewport","innerWidth","innerHeight","origin","x","y","z","noise","let","random","generateNoise","devicePixelRatio","drawers","target","props","Array","from","querySelectorAll","isArray","map","element","push","create","steps","sanitizeGradient","gradient","colors","flip","patternOpacity","type","dirty","styles","angle","scalar","data","toDataURL","size","getStateFromProps","init","getComputedStyle","update","style","position","wrapper","className","overlayStyles","overlay","borderTopWidth","parseFloat","borderLeftWidth","borderRightWidth","borderBottomWidth","borderTopLeftRadius","backgroundColor","fill","cssText","appendChild","innerHTML","mask","insertAdjacentElement","offset","gradientString","value","stop","join","backgroundImage","setup","drawer","write","read","step","color","length","index","arr","Object","colorRGBA","toRGBA","toRGB","slice","test","node","body","out","parentNode","removeChild","degToRad","degrees","tick","cos","sin","viewportScaleFactor","px","py","forEach","draw","requestAnimationFrame","addEventListener","e"],"mappings":"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"}